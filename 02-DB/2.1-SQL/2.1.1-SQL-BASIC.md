# SQL cơ bản
## 1. Data type
-Các kiểu dữ liệu có sẵn trong DBMS:
    - Scalar data types: được sử dụng để lưu trữ các giá trị vô hướng như số, số thập phân, v.v.
    - Composite data types hoặc User Define data types: các kiểu dữ liệu này được nhà phát triển xác định trong khi mã hóa bằng các kiểu dữ liệu cơ sở ở trên. Họ xác định các kiểu dữ liệu mới để dễ dàng mã hóa. Đây cũng có thể được coi là kiểu dữ liệu tổng hợp. : 
    - Reference data types: được sử dụng để lưu trữ thông tin về một kiểu dữ liệu khác. Nó có thể được coi là con trỏ trong C
    - LOB data types : Được sử dụng để lưu trữ các đối tượng lớn như hình ảnh, video, v.v.
    - Unknown Column types: khi cột không xác định được kiểu dữ liệu, kiểu dữ liệu này được sử dụng.
### 1.1.1 Scalar data types
- Có 4 kiểu dữ liệu trong Scalar data types
    - Character Data type: loại dữ liệu này được sử dụng để lưu các giá trị chữ-số như bảng chữu cái, các kí tự đặc biệt (CHAR, CHARACTER, VARCHAR2,  NCHAR...)
    - Numeric Datatypes: Lưu trữ các loại dữ liệu số khác nhau như số, số thập phân, v.v.(NUMBER (p, s), BINARY_INTEGER...)
    - Date / Time Datatypes: các kiểu dữ liệu này được sử dụng để lưu trữ thời gian(DATE, TIMESTAMP)
    - Boolean Datatypes: sử dụng để lưu trữ các giá trị boolean - TRUE hoặc FALSE. Nó cũng có thể lưu trữ NULL và được coi là biến boolean không dấu. Chúng tôi không thể so sánh các cột boolean của hai bảng.

### 1.1.2 Composite data types hoặc User Define data types
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Composite data types hoặc User Define data types: đây là kiểu dữ liệu tổng hợp hoặc là kiểu dữ liệu do người dùng tự định nghĩa ra. Để triển khai một biến dưới dạng kiểu dữ liệu tổng hợp, chúng ta cần xác định kiểu dữ liệu tổng hợp theo nhu cầu của chúng ta, sau đó sẽ gắn cho các biến để có các bản ghi như vậy
>Cú pháp: 
    `TYPE record_type_name IS RECORD 
    (Column1 DATATYPE, Column2 DATATYPE… ColumnN DATATYPE);`
    >
    >Ex: `TYPE rc_emp IS RECORD 
(id NUMBER, name VARCHAR2 (15), birth_day DATE);`

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ở đây rc_emp là tên của kiểu dữ liệu tổng hợp. Trên đây là cú pháp tạo kiểu dữ liệu tổng hợp. Khi nó được tạo, nó có thể được gán cho biến trong hai phương thức.

- __vr_emp_record rc_emp__: Khai báo một biến ‘vr_emp_record’ với ba cột có kiểu dữ liệu khác nhau. Biến này bây giờ có thể chứa một mảng hoặc bảng dữ liệu. Mỗi cột bên trong biến này có thể được gọi là vr_emp_record.emp_id, vr_emp_record.emp_name và vr_emp_record.date_of_birth
>
    > code:
    `rc_emp_id vr_emp_record.emp_id%TYPE;`
    `rc_emp_name vr_emp_record.emp_name%TYPE;`
    `rc_date_of_birth vr_emp_record. date_of_birth %TYPE;`
>
Ưu điểm: Không cần xác định rõ ràng các kiểu dữ liệu cột. Chúng sẽ được lấy tự động từ các bảng. Khi bảng được thay đổi đối với một số kiểu dữ liệu cột hoặc độ dài cột, nó sẽ tự động được phản ánh trong mã. Không cần sửa đổi mã khi có thay đổi bảng.

Nhược điểm: Khi một bản ghi được tạo bằng ROWTYPE, toàn bộ các cột được gán cho biến bản ghi. Bộ nhớ sẽ được sử dụng để tạo kiểu dữ liệu của tất cả các cột. Dev có thể chỉ cần một số cột để viết mã, nhưng các cột khác cũng được tạo trong bản ghi một cách không cần thiết.
### 1.1.3 Reference data types
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kiểu dữ liệu này hoạt động giống như con trỏ đến biến. Một trong những ví dụ về kiểu dữ liệu tham chiếu là con trỏ chuột. Chúng là các biến con trỏ được sử dụng để tham chiếu và truy cập con trỏ tĩnh. Chúng ta có thể chuyển biến này cho các thủ tục / hàm và nhận các giá trị từ hàm như một con trỏ chuột. Trong ngắn hạn, nó hoạt động một biến, nhưng tham chiếu đến truy vấn được xác định trong thời gian chạy.
### 1.1.4 LOB data types
Các loại kiểu dữ liệu này được sử dụng để lưu trữ lượng dữ liệu rất lớn trong một cột / biến. Nó có thể lưu trữ tệp như nhạc, đồ họa, v.v.
- BFILE: Được sử dụng để lưu trữ các đối tượng nhị phân lớn vào tệp Hệ điều hành. BFILE lưu trữ đường dẫn của trình định vị tệp đầy đủ là các điểm đến một đối tượng nhị phân được lưu trữ trong máy chủ. Loại dữ liệu BFILE ở chế độ chỉ đọc, bạn không thể sửa đổi chúng.
- BLOB: Giống BFILE, được sử dụng để lưu trữ đối tượng nhị phân không có cấu trúc vào tệp Hệ điều hành. Các giao dịch được hỗ trợ đầy đủ kiểu BLOB có thể phục hồi và nhân rộng.
- CLOB: Các khối dữ liệu ký tự lớn được lưu trữ vào Cơ sở dữ liệu bằng cách sử dụng kiểu dữ liệu này. Lưu trữ dữ liệu ký tự byte đơn và ký tự nhiều byte. Các loại CLOB là các giao dịch được hỗ trợ đầy đủ, có thể phục hồi và nhân rộng.
- NCLOB: dùng để lưu trữ các khối dữ liệu NCHAR lớn vào Database. Lưu trữ dữ liệu ký tự byte đơn và ký tự nhiều byte.
### 1.1.5 Unknown Column types
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ta đã thấy điều này trong các kiểu dữ liệu do người dùng định nghĩa để khai báo các biến. Đây được gọi là cột không xác định vì loại kiểu dữ liệu này không phải là kiểu dữ liệu cơ sở và được xác định bởi người dùng hoặc các bảng. Ta không dự đoán kiểu dữ liệu của nó chỉ bằng cách nhìn thấy tên hoặc khai báo. Ta phải xem định nghĩa của kiểu dữ liệu bản ghi để hiểu nó.

## Bảng tóm tắt data type
![Data type](.\images\DataType.PNG)

## 1.2 NULL 
- NULL trong SQL là thuật ngữ được sử dụng để biểu diễn một giá trị bị khuyết thiếu. Giá trị NULL trong một bảng là giá trị trong một trường bị bỏ trống. Trường có giá trị NULL là trường không có giá trị nào.
- Giá trị NULL sẽ khiến cho câu truy vấn của chúng ta trong một số trường hợp trở nên sai:
  - Khi sắp xếp các giá trị null được coi là giá trị lớn nhất có thể
  - Count: Giá trị null không được tính trong phép count, tuy nhiên count(*) sẽ đếm cả giá trị null
  - Trong AVG các giá trị null không đưa vào phép tính trung bình. Nếu muốn tính giá trị trung bình có null ta phải sử dụng `COALESCE` như ví dụ sau
```sql
select avg(COALESCE(amount,0)) as abc from orders 
```
## 1.3 Case when
### 1.3.1 Khái niệm
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hàm case được sử dụng để phân chia điều kiện trong sql. Hàm case được chia làm 2 loại là CASE thông thường (simple case) và hàm CASE tìm kiếm (searched case)
``` sql
Hàm CASE thông thường

CASE sex
  WHEN '1' THEN 'Nam'
  When '2' THEN 'Nữ'
ELSE 'Khác' END

Hàm CASE tìm kiếm

CASE WHEN sex = '1' Then 'Nam'
     WHEN sex = '2' Then 'Nữ'
ELSE 'Khác' END
```
Đầu ra của dữ liệu sẽ được hiên thị dưới dạng ngang:
<p align="center" width="100%">
    <img width="100%" src=".\images\Case.PNG"> 
</p>

Khi sử dụng hàm CASE thì chúng ta phải chú ý những điểm sau.
- Thống nhất dạng dữ liệu kết quả sau khi phân kì.
- Chú ý không quên viết END.
- Nhất định phải viết câu ELSE: không có else thì nó sẽ tự động hiệu là `Else Null`. Code sẽ không sai nhưng trong một số trường hợp kết quả sẽ khác.
### 1.3.2 Các trường hợp nên sử dụng case
- Thực hiện tập hợp những điều kiện khác nhau chỉ trong một dòng SQL

Ví dụ tổng hợp số sinh viên nam và nứ của một trường học có dữ liệu như bảng sau
<p align="center" width="100%">
    <img width="50%" src=".\images\Class.PNG"> 
</p>

Thông thường chúng ta cần sử dụng 2 câu truy vấn 
```sql
--Dân số nam
SELECT gender
       SUM(quantity)
  FROM class
  WHERE sex = '1'
  GROUP BY gender;

--Dân số nữ
SELECT gender
       SUM(quantity)
  FROM class
  WHERE sex = '2'
  GROUP BY gender;
```
Thay vào đó ta cớ thể sử dụng câu truy vấn sau
```sql
SELECT gender,
       --Dân số nam
       SUM( CASE WHEN sex = '1' THEN quantity ELSE 0 END) AS nam
       --Dân số nữ
       SUM( CASE WHEN sex = '2' THEN quantity ELSE 0 END) AS nữ
    FROM Class
  GROUP BY gender
```
- Sau khi phân kì trong điều kiện UPDATE: Đối với dãy giá trị số, chúng ta suy nghĩ đến trường hợp muốn chuyển giá trị hiện tại thành một giá trị khác như một đối tượng. Vấn đề là trường hợp điều kiện của UPDATE lúc đó sẽ được phân chia khá phức tạp

Ví dụ như update lương nhân viên với tập dữ liệu sau
<p align="center" width="100%">
    <img width="50%" src=".\images\Salary.PNG"> 
</p>

Bây giờ đối với bảng này, chúng ta sẽ cập nhật lại lương theo điều kiện dưới đây.
- Đối với những nhân viên có số lương hiện tại trên 300000 USD thì sẽ giảm 10% lương.
- Đối với những nhân viên có mức lương hiện tại từ 250000 đến 280000 USD thì tăng 20% lương.

Thông thường ta update như sau
```sql
--Điều kiện 1
UPDATE Personnel
   SET salary = salary * 0.9
 WHERE salary >= 300000;
UPDATE Personnel
   SET salary = salary * 1.2
 WHERE salary >= 250000 AND salary < 280000;
```
Kết quả của câu truy vấn trên sẽ là:
<p align="center" width="100%">
    <img width="50%" src=".\images\Result.PNG"> 
</p>
Và kết quả trên đã bị sai do những người có mức luwong trên 300000 USD đã bị update hai lần
Vậy nên chúng ta phải sử dụng hàm case trong trường hợp này:

```sql 
--Cập nhật đúng được viết bằng hàm CASE
UPDATE Personel
   SET salary = CASE WHEN salary >= 300000
                     THEN salary*0.9
                     WHEN salary >= 250000 AND salary < 280000
                     THEN salary*1.2
                     ELSE salary END;

```

# SQL nâng cao
## 1 Truy vấn đệ quy
Truy vấn đệ quy là một cách để truy vấn phân cấp dữ liệu, chẳng hạn như cấu trúc tổ chức, hóa đơn nguyên vật liệu và phân cấp tài liệu.
Ví dụ: tập cơ sở dữ liệu quản lý nhân viên có cấu trúc bảng
```sql
CREATE TABLE employee
      (employee_number INTEGER
      ,manager_employee_number INTEGER
      ,last_name CHAR(20)
      ,first_name VARCHAR(30));
```
 Tập dữ liệu có cấu trúc như sau
<p align="center" width="100%">
    <img width="100%" src=".\images\Ch03.04.09.1.jpg"> 
</p>

Câu truy vấn sau đây sẽ truy xuất tất cả các nhân viên dưới sự quản lý trực tiếp hoặc gián tiếp của nhân viên có mã số 801
```sql
WITH temp_table (employee_number) AS
   ( SELECT root.employee_number
     FROM employee root
     WHERE root.manager_employee_number = 801
   UNION ALL 
     SELECT indirect.employee_number
     FROM temp_table direct, employee indirect
     WHERE direct.employee_number = indirect.manager_employee_number
   )
   SELECT * FROM temp_table ORDER BY employee_number;
```
Tập kết quả ban đầu được thiết lập trong temp_table bởi câu lệnh không đệ quy chứa các nhân viên báo cáo trực tiếp cho người quản lý với số lượng worker_number là 801:
```sql
   SELECT root.employee_number
   FROM employee root
   WHERE root.manager_employee_number = 801 
   ```
Quá trình đệ quy diễn ra bằng cách truy xuất nhân viên trong dưới sự quản lý trực tiếp của những nhân viên temp_table. UNION ALL thêm các kết quả vào temp_table.
```sql
SELECT indirect.employee_number
  FROM temp_table direct, employee indirect
  WHERE direct.employee_number = indirect.manager_employee_number
```
Kết quả của câu truy vấn:
<p align="center" width="100%">
    <img width="50%" src=".\images\ResultRecursive.PNG"> 
</p>

Nếu cấu trúc phân cấp là tuần hoàn hoặc nếu câu lệnh đệ quy chỉ định điều kiện kết hợp không hợp lệ, thì một truy vấn đệ quy có thể tạo ra một truy vấn chạy không bao giờ hoàn thành với một kết quả hữu hạn. Cách tốt nhất là kiểm soát độ sâu của đệ quy:
```sql
WITH temp_table (employee_number, depth) AS
   ( SELECT root.employee_number, 0 AS depth
     FROM employee root
     WHERE root.manager_employee_number = 801 
   UNION ALL 
     SELECT indirect.employee_number, direct.depth+1 AS newdepth
     FROM temp_table direct, employee indirect
     WHERE direct.employee_number = indirect.manager_employee_number
     AND newdepth <= 5
   )
   SELECT * FROM temp_table ORDER BY employee_number;
```
## 2 View trong sql
View trong sql là một loại bảng ảo. Một dạng xem cũng có các hàng và cột như chúng nằm trong một bảng thực trong cơ sở dữ liệu. Chúng ta có thể tạo dạng xem bằng cách chọn các trường từ một hoặc nhiều bảng có trong cơ sở dữ liệu. Chế độ xem có thể có tất cả các hàng của bảng hoặc các hàng cụ thể dựa trên điều kiện nhất định.

- Cú pháp tạo View
```sql
Syntax:
CREATE VIEW view_name AS
SELECT column1, column2.....
FROM table_name
WHERE condition;
```
Cú pháp update View
```sql
UPDATE < view_name > SET<column1>=<value1>,<column2>=<value2>,.....
WHERE <condition>;
```
- Để có thể update thì View phải thỏa mãn một số điều kiện sau:
    - Câu lệnh SELECT được sử dụng để tạo View không được bao gồm mệnh đề GROUP BY hoặc mệnh đề ORDER BY.
    - Câu lệnh SELECT không được có từ khóa DISTINCT.
    - View phải có tất cả các giá trị NOT NULL.
    - View không nên được tạo bằng cách sử dụng các truy vấn lồng nhau hoặc các truy vấn phức tạp.
    - View nên được tạo từ một bảng duy nhất. Nếu View được tạo bằng nhiều bảng thì chúng tôi sẽ không được phép cập nhật View.
Cú pháp xóa một View
```sql
DROP VIEW view_name;
```
Bạn có thể sử dụng `CREATE OR REPLACE VIEW ` để thêm hoặc xóa các trường khỏi View
```sql
Syntax
CREATE OR REPLACE VIEW view_name AS
SELECT column1,coulmn2,..
FROM table_name
WHERE condition;
```
Chúng ta cũng có thể chèn một hàng vào View như đối với bảng bình thường

Việc sử dụng View trong database là rất hữu ích vi:
- Hạn chế quyền truy cập dữ liệu: View cung cấp một mức độ bảo mật bổ sung cho bảng bằng cách hạn chế quyền truy cập vào tập hợp các hàng và cột được xác định trước của bảng.
- Ẩn dữ liệu phức tạp: View có thể ẩn sự phức tạp tồn tại trong một phép nối nhiều bảng.
- Đơn giản hóa các lệnh cho người dùng: View cho phép người dùng chọn thông tin từ nhiều bảng mà không yêu cầu người dùng thực sự biết cách thực hiện phép nối.
- Lưu trữ các truy vấn phức tạp: View có thể được sử dụng để lưu trữ các truy vấn phức tạp.
- Đổi tên các cột: view cũng có thể được sử dụng để đổi tên các cột mà không ảnh hưởng đến bảng cơ sở với điều kiện số lượng cột trong chế độ xem phải khớp với số cột được chỉ định trong câu lệnh select. Do đó, việc đổi tên sẽ giúp ẩn tên của các cột của bảng cơ sở.
- Cơ sở nhiều góc nhìn: View khác nhau có thể được tạo trên cùng một bảng cho những người dùng khác nhau.
## 3 Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hàm là một chương trình con được sử dụng để trả về một giá trị duy nhất. Bạn phải khai báo và xác định một hàm trước khi gọi nó. Nó có thể được khai báo và định nghĩa cùng một lúc hoặc có thể được khai báo trước và định nghĩa sau trong cùng một khối.
```sql
Syntax
CREATE [OR REPLACE] FUNCTION function_name  
   [ (parameter [,parameter]) ]  
RETURN return_datatype  
IS | AS  
 [declaration_section]  
BEGIN   
   executable_section  
[EXCEPTION  
   exception_section]  
END [function_name];  
```
Ví dụ viết một function tính tổng hai số a và b
```sql
create or replace function adder(n1 in number, n2 in number)    
return number    
is     
n3 number(8);    
begin    
n3 :=n1+n2;    
return n3;    
end;  
```
Cú pháp xóa một function
```sql
DROP FUNCTION function_name;  
```
## 4 Procedure
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Procedure hay còn gọi là thủ tục, nó dùng để gom một nhóm lệnh SQL cùng xử lý một mục đích cụ thẻ nào đó, sau đó đặt cho nó một cái tên và khai bao tham số truyền vào để sau này mỗi khi cần sử dụng thì ta chỉ cần gọi tên và truyền tham số là được.

Cú pháp tạo proceduce:
```sql
CREATE [OR REPLACE] PROCEDURE procedure_name  
    [ (parameter [,parameter]) ]  
IS 
    [declaration_section]  
BEGIN 
    executable_section  
[EXCEPTION  
    exception_section]  
END [procedure_name];
```
Trong đó cần quan tâm đến một số lệnh sau:
- procedure_name là tên của procedure. 
- [OR REPLACE]: Khai báo tham số này thì nó sẽ xóa procedure có tên trùng với tên của procedure đang chạy
- [ (parameter [,parameter]) ] là các tham số truyền vào procedure

Ví dụ câu procedure insert dữ liệu vào bảng employee
```sql
create or replace procedure "INSERTUSER"   
    (id IN NUMBER,    
    name IN VARCHAR2)    
is   
begin   
     insert into user values(id,name);    
end;
```
Gọi thực thi procedure
```sql
DECLARE
amount NUMBER;
BEGIN
PROC1(1000001, amount);
dbms_output.put_line(amount);
END;
```
Cú pháp xóa procedure:
```sql
DROP PROCEDURE procedure_name;
```
## 5 Trigger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trong hệ quản trị CSDL thì chúng ta có ba thao tác làm thay đổi dữ liệu chính đó là: UPDATE, INSERT và DELETE. Và đôi lúc bạn muốn thực hiện một hành động gì đó trước khi hoặc sau khi 3 lệnh đó xảy ra, và cái này ta gọi là trigger.

Như vậy chúng ta có 6 câu lệnh để tạo trigger chính, hay nói cách khác là 6 hành động và gom thành hai nhóm.
- Nhóm before:
    - BEFORE INSERT TRIGGER
    - BEFORE UPDATE TRIGGER
    - BEFORE DELETE TRIGGER
- Nhóm after:
    - AFTER INSERT TRIGGER
    - AFTER UPDATE TRIGGER
    - AFTER DELETE TRIGGER

Lưu ý:
- Bạn không thể tạo Before Trigger cho View
- Bạn không thể cập nhật dữ liệu cũ, chỉ co thể cập nhật dữ liệu mới.
### 5.1 After trigger
After trigger là những trigger sẽ được thực thi sau khi hành động chính hoàn thành. 

Cú pháp:
```sql
CREATE [ OR REPLACE ] TRIGGER trigger_name  
AFTER INSERT OR UPDATE OR DELETE 
 ON table_name  
  [ FOR EACH ROW ]  
   
DECLARE 
   -- variable declarations  
    
BEGIN 
   -- trigger code  
    
EXCEPTION  
   WHEN ...  
   -- exception handling  
END;
```
Ví dự ta có một bảng như sau và thực hiện các câu after trigger:
```sql
CREATE TABLE orders
( order_id number(5),
  quantity number(4),
  cost_per_item number(6,2),
  total_cost number(8,2)
);

// AFTER DELETE

CREATE OR REPLACE TRIGGER orders_after_delete
AFTER DELETE
   ON orders
   FOR EACH ROW
 
DECLARE
   v_username varchar2(10);
 
BEGIN
   -- Find username of person performing the DELETE on the table
   SELECT user INTO v_username
   FROM dual;
 
   -- Insert record into audit table
   INSERT INTO orders_audit
   ( order_id,
     quantity,
     cost_per_item,
     total_cost,
     delete_date,
     deleted_by)
   VALUES
   ( :old.order_id,
     :old.quantity,
     :old.cost_per_item,
     :old.total_cost,
     sysdate,
     v_username );
 
END;


//AFTER INSERT

CREATE OR REPLACE TRIGGER orders_after_insert
AFTER INSERT
   ON orders
   FOR EACH ROW
 
DECLARE
   v_username varchar2(10);
 
BEGIN
 
   -- Find username of person performing the INSERT into the table
   SELECT user INTO v_username
   FROM dual;
 
   -- Insert record into audit table
   INSERT INTO orders_audit
   ( order_id,
     quantity,
     cost_per_item,
     total_cost,
     username )
   VALUES
   ( :new.order_id,
     :new.quantity,
     :new.cost_per_item,
     :new.total_cost,
     v_username );
 
END;

// AFTER UPDATE

CREATE OR REPLACE TRIGGER orders_after_update
AFTER UPDATE
   ON orders
   FOR EACH ROW
 
DECLARE
   v_username varchar2(10);
 
BEGIN
 
   -- Find username of person performing UPDATE into table
   SELECT user INTO v_username
   FROM dual;
 
   -- Insert record into audit table
   INSERT INTO orders_audit
   ( order_id,
     quantity_before,
     quantity_after,
     username )
   VALUES
   ( :new.order_id,
     :old.quantity,
     :new.quantity,
     v_username );
 
END;
```
### 5.2 Before Trigger
Before Trigger là những trigger sẽ thực thi trước hành động chính, nghĩa là xử lý nó xong thì hành động chính mới được thực hiện.

Cú pháp tạo before trigger
```sql
CREATE [ OR REPLACE ] TRIGGER trigger_name
BEFORE DELETE
   ON table_name
   [ FOR EACH ROW ]
 
DECLARE
   -- variable declarations
 
BEGIN
   -- trigger code
 
EXCEPTION
   WHEN ...
   -- exception handling
 
END;
```
### 5.3 Các lệnh thao tác với trigger khác
Disable trigger cho table:
- Muốn tắt một trigger của bảng ta sử dụng lệnh:
```sql
ALTER TRIGGER trigger_name DISABLE;
```
- Muốn tắt tất cả trigger của bảng ta sử dụng lệnh:
```sql
ALTER TABLE table_name DISABLE ALL TRIGGERS;
```
Enable trigger:
- Nếu muốn bật một trigger đã tắt cho table ta dùng cú pháp sau:
```sql
ALTER TRIGGER trigger_name ENABLE;
```
- Nếu muốn bật tất cả trigger đã tắt cho table ta dùng cú pháp sau:
```sql
ALTER TABLE table_name ENABLE ALL TRIGGERS;
```
Nếu muốn xóa trigger vĩnh viễn ta sử dụng lệnh drop trigger.
```sql
DROP TRIGGER trigger_name;
```
## 6 Index
Trước khi tìm hiểu về index chúng ta sẽ tìm hiểu sơ bộ về B-tree.
- B-tree là môt cây tìm kiếm tự cân bằng(là câu có số nút con trái chênh lệch không quá một so với số nút của cây con phải).
- Cây nhị phân tìm kiếm có các đặc điểm sau:
  - Tất cả các nút lá phải ở cùng một mức
  - Tất cả các nút ngoại trừ gốc phải có ít nhất [m / 2] -1 khóa và tối đa m-1 khóa
  - Tất cả các nút không phải lá ngoại trừ gốc (tức là tất cả các nút bên trong) phải có ít nhất m / 2 nút con.
  - Nếu nút gốc là nút không phải là nút lá thì nó phải có ít nhất 2 nút con
  - Một nút không phải là nút lá có n-1 khóa phải có n số nút con.
  - Tất cả các giá trị khóa trong một nút phải theo Thứ tự tăng dần.
<p align="center" width="100%">
    <img src=".\images\Delete-key-from-Btree-2.png"> 
</p>

### Index là gì?
&emsp;&emsp;Index là một cấu trúc dữ liệu được tạo trên một hoặc nhiều cột của bảng. Trong hầu hết các trường hợp, Index được cấu trúc như B-tree. Khi Index được tạo trên một cột của bảng, nó thực sự tạo ra một bảng tra cứu với cột và một con trỏ đến địa chỉ bộ nhớ nơi thực sự lưu trữ một hàng có cột này. 
<p align="center" width="100%">
    <img src=".\images\index.PNG"> 
</p>

Cơ chế đánh index:
- Giả sử chúng ta có 1 triệu record tên người, và một người ở một tỉnh/thành nhất định. Ta cần tìm ra người ở tỉnh "Nam Định" có tên là "Nam". Cơ chế index lúc này sẽ hoạt động như sau:

  - Đầu tiên bạn sẽ cần đánh index cho cả trường :province và cả trường :name, lúc này 1 triệu record sẽ đc nhóm lại theo province trước, các province này sẽ được sắp xếp theo thứ tự alphabet, ví dụ "An Giang" có index là 0, "Bà Rịa Vũng Tàu" có index là 1, "Bắc Giang" có index là 2, ... Trong nhóm tỉnh/thành, các trường :name lại được đánh index 1 lần nữa. Ví dụ: "An" : 0, "Anh": 1, "Ánh": 2, ... Việc đánh index trong index như thế này tạo nên các nhánh, nên người ta gọi là B tree.

  - Khi thực hiện câu truy vấn Select ...where province = "Ninh Bình" and name = "Nam". Đầu tiên sẽ lọc ra những người ở tỉnh "Ninh Bình". Cơ chế như sau, mỗi tỉnh lấy ra record đầu tiên và đem so sánh với "Ninh Bình" theo phương pháp đánh index, Việt Nam có 64 tỉnh nên chỉ cần tối đa 6 lần so sánh là sẽ tìm đc người nào thuộc tỉnh "Ninh Bình", từ người đó sẽ lấy ra toàn bộ nhóm đó, sau đó từ nhóm người đó lại dùng phương pháp index lọc ra người tên "Nam" một lần nữa.

Cú pháp Index
- Tạo index
```sql
CREATE [UNIQUE] INDEX index_name
ON table_name (column1, column2, ...);
``` 
Từ khóa `UNIQUE` sẽ tạo các giá trị index không trùng lặp
- Xóa index:
```sql 
DROP INDEX index_name;
```
Tuy nhiên không phải lúc nào chúng ta cũng sử dụng index vì index làm giảm hiệu năng của các câu `INSERT`, `UPDATE`, `DELETE` và chiếm dụng bộ nhớ.Vì vậy chúng ta cần xem xét trước khi sử dụng index. Ta có thể xem xét dùng index trong một vài trường hợp sau.
- Các cột được lập Index được truy vấn thường xuyên và trả về một tỷ lệ phần trăm nhỏ trong tổng số hàng trong bảng.
- Một ràng buộc  integrity constraint (tham chiếu toàn v) tồn tại trên cột hoặc các cột được lập Index. Index là một phương tiện để tránh khóa bảng đầy đủ mà nếu không sẽ được yêu cầu nếu bạn cập nhật khóa chính của bảng cha, hợp nhất vào bảng cha hoặc xóa khỏi bảng cha.
- Một ràng buộc khóa duy nhất sẽ được đặt trên bảng và bạn muốn chỉ định index và tất cả các tùy chọn index theo cách thủ công.